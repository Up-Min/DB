--CREATE TABLE EMP (
--    NO NUMBER,
--    NAME VARCHAR2(20),
--    AGE NUMBER
--);


--CREATE TABLE ORDERS(
--    ORDER_ID NUMBER PRIMARY KEY,
--    SALESMAN_ID NUMBER,
--    ORDER_DATE DATE NOT NULL -- 날짜관련 DATE 선언
--)

-- QUIZ 1.
--CREATE TABLE CATEGORIES(
--    CATEORY_ID NUMBER PRIMARY KEY,
--    CATEGORY_NAME VARCHAR2(100) NOT NULL
--);
-- QUIZ 2.
--CREATE TABLE LOCATION(
--    LOCATION_ID NUMBER PRIMARY KEY,
--    ADDRESS VARCHAR2(255) NOT NULL,
--    POSTAL_CODE VARCHAR2(20),
--    CITY VARCHAR2(50) 
--);


--INSERT
--INSERT INTO customer(ID, NAME, ADDRESS) VALUES(1, '둘리', '인천');
--INSERT INTO customer VALUES(2, '둘리', '인천'); 
--INSERT INTO CUSTOMER (ID, NAME) VALUES(3, '또치'); 
--INSERT INTO CUSTOMER (ID, NAME) VALUES(4,  '또치' ); 
--INSERT INTO CUSTOMER (ID, ADDRESS) VALUES(5, '서울'); 
--INSERT INTO CUSTOMER VALUES (5, '둘리', '');
--INSERT INTO CUSTOMER VALUES(6,'홍길동',NULL);
--INSERT INTO CUSTOMER (ID, NAME) VALUES(3, '홍길동'); -- 
--INSERT INTO CUSTOMER (ID) VALUES(6);

--CREATE TABLE CUSTOMER(
--    ID NUMBER PRIMARY KEY,
--    NAME VARCHAR2(20) NOT NULL,
--    ADDRESS VARCHAR2(10),
--    ADDRESS CHAR(10)
--); -- CUSTOMER NAME VARCHAR20 - 한글 6자 입력 가능? 
--
--INSERT INTO CUSTOMER VALUES(7, '홍길동홍길동', NULL);
--
--select * from nls_database_parameters where parameter = 'NLS_CHARACTERSET';

--NUMBER (P : 최대 유효 자릿수, S: 소수 자릿수) 가장 많이 쓴다!
--IF
--NUMBER(3) -> 3BYTE 사용, (정수 3자리)
--NUMBER(5,2) -> 전체 5자리 확보, 정수 3자리 소수점 이하 3자리ㅔ서 반올림해서 2번째 자리까지 표현
--NUMBER(5,-1) -> 전체 5자리 확보, 정수 3자리 소수점 왼쪽 첫자리가 반올림 됨)
-- 자릿수는 5자리를 넘어가지만 않으면 된다. 5자리를 넘어가게 되면 뒤에 있는 자리는 잘리게 됨.

--FLOAT
--실수형으로 소수점 데이터를 저장함. 
--FLOAT(3) -> 3BYTE사용 (소수점을 포함한 3자리)

CREATE TABLE EMP2(
    EMPNO NUMBER (5) NOT NULL, -- 5자리 정수
    NUM1 NUMBER(6), --5자리의 정수
    NUM2 NUMBER(6,2), -- 5자리의 숫자 
    -- (정수는 3자리, 소숫점은 2자리, 양수인경우에는 소숫점 이하 3번째 자리에서 반올림 12345.11 << 이런거 안 됨.)
    NUM3 NUMBER(5,-3)  -- 5자리의 숫자 ( -1번째 자리 기준 그 밑에 자리에서 반올림 함. 즉, 1의 자리(소숫점 왼쪽 첫자리) 에서 반올림 함)
);

INSERT INTO EMP2 VALUES(12345, 144343, 114.1443, 1124450.1567);


--DATE, TIMESTAMP
--
--DATE : 어마어마한 옛날부터 연도, 월, 일 , 시, 분, 초까지 입력 가능.
--TIMESTAMP : 연도, 월, 일, 시, 분, 초, 밀리초, 시간대 입력 가능.


-- ALTER - 컬럼을 추가하거나 삭제, 속성을 변경함.
--컬럼 데이터 추가(ADD), 컬럼명 변경(RENAME), 컬럼 크기 변경(MODIFY), 

--ALTER TABLE CUSTOMER ADD GENDER VARCHAR2(9); -- 컬럼추가
--ALTER TABLE CUSTOMER RENAME COLUMN GENDER TO GEN; -- 컬럼명 변경
--ALTER TABLE CUSTOMER RENAME COLUMN GEN TO GENDER; -- 컬럼명 변경
--ALTER TABLE CUSTOMER MODIFY GENDER VARCHAR2(100); -- 컬럼 VARCHAR2 크기 변경
--ALTER TABLE CUSTOMER MODIFY GENDER VARCHAR2(100) DEFAULT 'NONE' NOT NULL;
-- 테이블 크기 변경, 디폴트, NOT NULL 적용.
--ALTER TABLE CUSTOMER DROP COLUMN GENDER;  -- 컬럼 삭제
--INSERT INTO CUSTOMER VALUES(8, '홍길동', '인천', 'TEST');

--ALTER TABLE CUSTOMER MODIFY GENDER NUMBER; --젠더의 타입 변경
--COMMENT ON COLUMN customer.gender IS '성별'; -- 설명 달기


-- 12.7 quiz
ALTER TABLE EMP ADD SALARY NUMBER;
ALTER TABLE EMP MODIFY SALARY NOT NULL;
COMMENT ON COLUMN emp.age IS '코멘트' ;
COMMENT ON COLUMN emp.NAME IS '코멘트' ;
COMMENT ON COLUMN emp.SALARY IS '코멘트' ;
COMMENT ON COLUMN emp.NO IS '코멘트' ;

ALTER TABLE ORDERS ADD CUSTOMER_NAME VARCHAR(50) NOT NULL;
ALTER TABLE ORDERS MODIFY SALESMAN_ID VARCHAR(50);
ALTER TABLE ORDERS RENAME COLUMN SALESMAN_ID TO SALESMAN_NAME;
ALTER TABLE ORDERS MODIFY ORDER_DATE NULL;

COMMENT ON COLUMN orders.customer_name IS '코멘트';
COMMENT ON COLUMN orders.order_date IS '코멘트';
COMMENT ON COLUMN orders.order_id IS '코멘트';
COMMENT ON COLUMN orders.salesman_name IS '코멘트';

-- 테이블 삭제
DROP TABLE EMP;
DROP TABLE EMP2;
DROP TABLE ORDERS;
DROP TABLE LOCATION;
DROP TABLE CUSTOMER;
DROP TABLE CATEGORIES;

INSERT INTO ORDERS(ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES (1001, 1002, SYSDATE); -- 현재시간 SYSDATE
INSERT INTO ORDERS(ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES (1002, 1003, '2022-10-13'); -- 특정시간도 넣을 수 있음
INSERT INTO ORDERS(ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES (1003, 1002, TO_DATE('2022-10-13', 'YYYY-MM-DD')); --TO_DATE, 기입할 날짜와 포맷 작성
INSERT INTO ORDERS(ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES (1004, 1002, TO_DATE('2022-10-13 12:00:00', 'YYYY-MM-DD HH24:MI:SS')); --TO_DATE, 기입할 날짜와 포맷 작성 (초까지!)

--QUIZ 1
CREATE TABLE BOOK(
BOOK_NO NUMBER PRIMARY KEY,
TITLE VARCHAR2(100),
PUBLISHER VARCHAR2(100),
PRICE NUMBER
);

--QUIZ 2
INSERT INTO BOOK (BOOK_NO, TITLE, PUBLISHER, PRICE) VALUES (1, '역사1', '상상마당', 30000);
INSERT INTO BOOK (BOOK_NO, TITLE, PUBLISHER, PRICE) VALUES (2, '역사2', '상상마당', 30000);
INSERT INTO BOOK (BOOK_NO, TITLE, PUBLISHER, PRICE) VALUES (3, '스프링웹프로젝트', '한빛미디어', 50000);
INSERT INTO BOOK (BOOK_NO, TITLE, PUBLISHER, PRICE) VALUES (4, '자바개발도서', '생능출판', '');

--QUIZ 3
INSERT INTO EMP (NO, NAME, AGE) VALUES('','','');
INSERT INTO EMP (NO, NAME, AGE) VALUES('1','','');
INSERT INTO EMP (NO, NAME, AGE) VALUES('','물리','10');
INSERT INTO EMP (NO, NAME, AGE) VALUES('1','물리',10);
INSERT INTO EMP (NO, NAME, AGE) VALUES(1,'물리',10);

--QUIZ 4
CREATE TABLE CONTACT(
CONTACT_NO   NUMBER PRIMARY KEY,
FIRST_NAME     VARCHAR2(100),
LAST_NAME      VARCHAR2(100),
EMAIL             VARCHAR2(100),
PHONE            VARCHAR2(100)
);

INSERT INTO CONTACT (CONTACT_NO, FIRST_NAME, LAST_NAME,EMAIL,PHONE) VALUES(1, '이','서연','flor.stone@gmail.com','010-3171-2341');
INSERT INTO CONTACT (CONTACT_NO, FIRST_NAME, LAST_NAME,EMAIL,PHONE) VALUES(2, '이','시우','lavera.emerson@gmail.com','010-3171-4111');
INSERT INTO CONTACT (CONTACT_NO, FIRST_NAME, LAST_NAME,EMAIL,PHONE) VALUES(3, '김','지호','shyla.ortiz@gmail.com','010-3171-4126');
INSERT INTO CONTACT (CONTACT_NO, FIRST_NAME, LAST_NAME,EMAIL,PHONE) VALUES(4, '김','윤서','jeni.levy@gmail.com','010-8121-2341');
INSERT INTO CONTACT (CONTACT_NO, FIRST_NAME, LAST_NAME,EMAIL,PHONE) VALUES(5, '최','수아','fern.head@gmail.com','');

--QUIZ 5
CREATE TABLE CALENDER(
MONTH       NUMBER,
DAY_WEEK    DATE,
DAY            DATE
);

ALTER TABLE CALENDER ADD MONTH NUMBER;
ALTER TABLE CALENDER MODIFY MONTH VARCHAR2(10);
ALTER TABLE CALENDER MODIFY DAY_WEEK VARCHAR2(10);
ALTER TABLE CALENDER MODIFY DAY VARCHAR2(10);

INSERT INTO CALENDER (MONTH, DAY_WEEK, DAY) VALUES('1', '일', '1');
INSERT INTO CALENDER (MONTH, DAY_WEEK, DAY) VALUES('1', '월', '2');
INSERT INTO CALENDER (MONTH, DAY_WEEK, DAY) VALUES('1', '화', '3');
INSERT INTO CALENDER (MONTH, DAY_WEEK, DAY) VALUES('1', '수', '4');
INSERT INTO CALENDER (MONTH, DAY_WEEK, DAY) VALUES('1', '목', '5');
INSERT INTO CALENDER (MONTH, DAY_WEEK, DAY) VALUES('1', '금', '6');
INSERT INTO CALENDER (MONTH, DAY_WEEK, DAY) VALUES('1', '토', '7');

--QUIZ 6
CREATE TABLE GIFTSET(
NO NUMBER PRIMARY KEY,
NAME VARCHAR2(100),
PRICE NUMBER
);

INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(1, '참치세트', 10000);
INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(2, '샴푸세트', 20000);
INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(3, '세차용품세트', 30000);
INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(4, '주방용품세트', 40000);
INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(5, '산악용세트', 50000);
INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(6, 'LCD모니터', 60000);
INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(7, '노트북', 70000);
INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(8, '벽걸이 TV', 80000);
INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(9, '드럼세탁기', 90000);
INSERT INTO GIFTSET (NO, NAME, PRICE) VALUES(10, '양쪽문냉장고', 1000000);

--UPDATE

--UPDATE 테이블 이름 SET 바꿀컬럼 = 변경할 값 WHERE 컬럼 = 넣을 값.
 --UPDATE CUSTOMER SET ADDRESS = '서울' -- 이렇게 하면 ADDRESS 전체가 '서울'로 바뀌게 됨.
UPDATE CUSTOMER SET ADDRESS = '서울' WHERE ID = 2; -- CUSTOMER에서 'ID'가 '2'인 컬럼의 값을 바꿈.

-- SET 값 2개 동시에 넣기
 UPDATE CUSTOMER SET NAME = '훈이', ADDRESS = '제주도' WHERE ID = 3; 
 -- SET 뒤에 바꿀컬럼 = 변경할 값, 바꿀컬럼 = 변경할 값 두개를 넣어서 두개 값을 한꺼번에 바꿀 수 있어짐.

-- DATE의 ORDER DATE 값 전부 지금 날짜로 바꾸기 
UPDATE ORDERS SET ORDER_DATE = SYSDATE WHERE ORDER_ID=1002;

UPDATE ORDERS SET ORDER_DATE = SYSDATE WHERE SALESMAN_ID=1002;
 -- SALESMAN_ID 가 같은 모든 아이들이 동시에 바뀜, 즉 하나로 고정되어있는게 아니라 본인이 뭘 바꾸고 싶은지에 따라 다양하게 사용 가능


--DELETE 

--DELETE FROM 테이블 이름 WHERE 컬럼 = 특정값
DELETE FROM CUSTOMER WHERE ID=4; -- CUSTOMER 안에서 ID가 4번인 애를 없앰
DELETE FROM CUSTOMER WHERE NAME='둘리'; -- CUSTOMER 안에서 NAME가 '둘리'인 애들을 없앰
DELETE FROM CUSTOMER; -- CUSTOMER 전체 행 삭제

-- 조건문에 AND.
DELETE FROM ORDERS WHERE ORDER_ID = 1001 AND SALESMAN_ID = 2002;
-- ORDER_ID가 1001, SALESMAN_ID가 2002인경우 없앤다.

--QUIZ1
UPDATE BOOK SET TITLE = '자바개발도서' WHERE BOOK_NO = 4;
--QUIZ 2
UPDATE BOOK SET PRICE = 30000 WHERE PUBLISHER = '상상마당';
--QUIZ 3
UPDATE CUSTOMER SET NAME = '둘리', ADDRESS = '인천';

--DELETE QUIZ 1
DELETE FROM BOOK WHERE TITLE = '역사2' AND PUBLISHER = '상상마당';
--QUIZ 2
DELETE FROM BOOK WHERE BOOK_NO = '3'; 
--QUIZ 3
DELETE FROM BOOK WHERE PRICE IS NULL; 
--QUIZ 4
DELETE FROM BOOK 

DROP TABLE CUSTOMER;
CREATE TABLE CUSTOMER (
    ID      NUMBER PRIMARY KEY,
    NAME    VARCHAR2(20) NOT NULL,
    ADDRESS VARCHAR2(100)
);
INSERT INTO CUSTOMER(ID, NAME, ADDRESS) VALUES(1, '둘리', '인천');
INSERT INTO CUSTOMER(ID, NAME, ADDRESS) VALUES(2, '둘리', '서울');
INSERT INTO CUSTOMER(ID, NAME, ADDRESS) VALUES(3, '홍길동','서울');
INSERT INTO CUSTOMER(ID, NAME, ADDRESS) VALUES(4, '또치', '제주도');
INSERT INTO CUSTOMER(ID, NAME, ADDRESS) VALUES(5, '도우너', '');
DROP TABLE ORDERS;
CREATE TABLE ORDERS (
    ORDER_ID    NUMBER PRIMARY KEY,
    SALESMAN_ID NUMBER,
    ORDER_DATE  DATE NOT NULL
);
INSERT INTO ORDERS(ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES(1001, 2002, '2022-01-01');
INSERT INTO ORDERS(ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES(1002, 2002, '2022-01-02');
INSERT INTO ORDERS(ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES(1003, 2002, '2022-01-03');
INSERT INTO ORDERS(ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES(1004, 2002, '2022-01-04');
DROP TABLE BOOK;
CREATE TABLE BOOK (
    BOOK_NO NUMBER PRIMARY KEY, --도서번호
    TITLE VARCHAR2(100) NOT NULL, --제목
    PUBLISHER VARCHAR2(100), --출판사
    PRICE NUMBER --가격
);
INSERT INTO BOOK (BOOK_NO, TITLE, PUBLISHER, PRICE) VALUES (1, '역사1', '상상마당', 10000);
INSERT INTO BOOK (BOOK_NO, TITLE, PUBLISHER, PRICE) VALUES (2, '역사2', '상상마당', 11000);
INSERT INTO BOOK (BOOK_NO, TITLE, PUBLISHER, PRICE) VALUES (3, '스프링웹프로젝트', '한빛미디어', 50000);
INSERT INTO BOOK (BOOK_NO, TITLE, PUBLISHER, PRICE) VALUES (4, '자바프로그래밍', '생능출판', 25000);
 DROP TABLE CONTACTS;
 CREATE TABLE CONTACTS 
  (
    CONTACT_NO NUMBER PRIMARY KEY,
    FIRST_NAME  VARCHAR2( 255 ) NOT NULL,
    LAST_NAME   VARCHAR2( 255 ) NOT NULL,
    EMAIL       VARCHAR2( 255 ) NOT NULL,
    PHONE       VARCHAR2( 20 )         
  );



--==== SELECT===== ----
--SELECT * FROM 테이블이름

SELECT * FROM CUSTOMER; -- 모든 컬럼을 다 가져온다

SELECT NAME FROM CUSTOMER; -- 해당 컬럼만 가져온다.

SELECT ID, NAME FROM CUSTOMER; -- 적은 순서대로 출력된다.

-- SELECT ORDER BY (정렬)
--SELECT * FROM 테이블이름 ORDER BY 컬럼 ASC -> 순정렬
--SELECT * FROM 테이블이름 ORDER BY 컬럼 DESC -> 역정렬

SELECT * FROM CUSTOMER ORDER BY ID ASC; -- 오름차순
SELECT * FROM CUSTOMER ORDER BY ID DESC; -- 내림차순
SELECT * FROM CUSTOMER ORDER BY ADDRESS DESC;  -- NULL값이 항상 맨 마지막에 간다.

-- 그룹화
--SELECT * FROM 테이블이름 GROUP BY 그룹화 할 컬럼
SELECT * FROM GIFT;
SELECT NAME FROM GIFT GROUP BY NAME;

SELECT NAME AS CUS FROM CUSTOMER; -- CUS라는 별칭을 붙여서 그룹화 시켜주게 됨.
SELECT TYPE, SUM(PRICE) AS SUM FROM GIFT GROUP BY TYPE; -- 그룹화 된 아이들의 합산된 값을 세어서 SUM이라는 별칭을 붙여서 빼준다.
-- TYPE와 
SELECT TYPE, COUNT(TYPE) AS COUNT FROM GIFT GROUP BY TYPE; -- 그룹화 된 아이들의 갯수를 세어서 COUNT 라는 별칭을 붙여서 빼준다.
SELECT TYPE, COUNT(NAME) AS COUNT FROM GIFT GROUP BY TYPE;
-- TYPE과 NAME의 갯수를 GIFT에서 가져와서, COUNT로 별칭을 붙여준다. 이걸 TYPE으로 그룹화 시켜준다



-- WHERE 조건검색
-- 비교연산자, 논리연산자, 산술연산자 -> 자바와 동일함.
-- 문자와 문자를 연결할 때 사용하는 합성연산자

-- 비교연산자
SELECT * FROM CUSTOMER WHERE ID = 1;
SELECT * FROM CUSTOMER WHERE ID > 1; -- ID 2,3,4,5 출력
SELECT * FROM CUSTOMER WHERE ID < 4; -- ID 1,2,3 출력
SELECT * FROM CUSTOMER WHERE ID >= 1;
SELECT * FROM CUSTOMER WHERE ID  <= 4;
SELECT * FROM CUSTOMER WHERE ID  !=1;

SELECT * FROM CUSTOMER WHERE NAME  = '둘리'; -- NAME 이 '둘리'인 애들 출력
SELECT * FROM CUSTOMER WHERE NAME > '둘리'; -- 둘라보다 위인 애들 (ㄱ,ㄴ,ㄷ 기준)
SELECT * FROM CUSTOMER WHERE NAME < '둘리'; -- 둘리보다 아래인 애들 (ㄱ,ㄴ,ㄷ 기준)

SELECT * FROM ORDERS WHERE ORDER_DATE = '22/01/01'; -- 1월 1일인 애들 
SELECT * FROM ORDERS WHERE ORDER_DATE > '22/01/01'; -- 1월 1일 이후인 애들

SELECT * FROM CUSTOMER WHERE NAME = '둘리' AND ADDRESS = '서울'; -- 둘리면서 서울인 애를 출력
SELECT * FROM CUSTOMER WHERE ADDRESS = '인천' OR ADDRESS = '서울'; -- ADDRESS가 인천 혹은 서울인 애를 출력
SELECT * FROM CUSTOMER WHERE NOT ADDRESS = '서울'; -- ADDRESS가 서울이 아닌 애를 출력 
-- 근데, 왜 NULL 값인 애는 안나오냐? 그냥 값이 없어서 아예 가져오지를 않는다! 아예 예외!

SELECT * FROM ORDERS;
SELECT ORDER_ID + SALESMAN_ID FROM ORDERS;  -- 두 ID더한 값이 출력, 별칭이 마음에 안들면 AS로 별칭을 지어주면 됨.
SELECT ORDER_ID + SALESMAN_ID AS PLUS FROM ORDERS; 
SELECT (ORDER_ID + SALESMAN_ID) * ORDER_ID AS PLUS FROM ORDERS; -- () 이용한 우선순위 지정

--||

SELECT NAME AS INTRO FROM CUSTOMER;
SELECT '이름 : ' || NAME || '입니다.' AS INTRO FROM CUSTOMER;
-- 자바의 +에 대응하는 ||, 문자열 연결이 가능함.

-- 53페이지
-- SELECT QUIZ1.
SELECT TITLE,PRICE FROM BOOK WHERE PRICE = 11000;
SELECT TITLE,PRICE FROM BOOK WHERE PRICE = 25000;
--QUIZ 2. 
SELECT TITLE,PRICE FROM BOOK WHERE PRICE > 30000;
--QUIZ 3.
SELECT TITLE,PRICE FROM BOOK WHERE PRICE > 10000 AND PRICE <=30000;
--QUIZ 4. 
SELECT TITLE,PUBLISHER FROM BOOK WHERE PUBLISHER = '한빛미디어' OR PUBLISHER = '생능출판' ;
--QUIZ 5.
SELECT * FROM ORDERS WHERE ORDER_DATE > '2022/01/02';
    -- 또 하나의 방법
    SELECT * FROM ORDERS WHERE ORDER_DATE > TO_DATE('2022/01/02','YYYY/MM/DD');
    -- 번외
    SELECT * FROM ORDERS WHERE ORDER_DATE < SYSDATE;
--QUIZ 6.
SELECT * FROM ORDERS WHERE ORDER_DATE > '2022/01/01';

-- 범위 연산자
-- BETWEEN , NOT BETWEEN, IN, NOT IN

SELECT * FROM CUSTOMER WHERE ID BETWEEN 2 AND 4; -- ID 값이 2와 4 사이의 아이들을 불러온다.
SELECT * FROM CUSTOMER WHERE ID NOT BETWEEN 2 AND 4; -- ID 값이 2와 4 사이'가 아닌' 아이들을 불러온다.
SELECT * FROM CUSTOMER WHERE ID IN (1,2,3); -- ID의 값이 1,2,3인 아이들을 불러온다.
SELECT * FROM CUSTOMER WHERE ID NOT IN (1,2,3); -- ID의 값이 1,2,3'이 아닌' 아이들을 불러온다.

-- 패턴연산자 LIKE, 해당 문자열을 포함하면 검색한다.
 SELECT * FROM CUSTOMER WHERE NAME LIKE '둘%'; -- '둘'로 시작하는 글자 출력
 SELECT * FROM CUSTOMER WHERE NAME LIKE '%길%'; -- '중간에 길이' 들어가는 글자 출력
 SELECT * FROM CUSTOMER WHERE NAME LIKE '%치'; -- '치'로 끝나는 글자 출력

-- 빈값 체크 연산자
-- IS NULL
-- IS NOT NULL

SELECT * FROM CUSTOMER WHERE ADDRESS IS NULL; -- ADDRESS 값이 NULL인 아이를 출력
SELECT * FROM CUSTOMER WHERE ADDRESS IS NOT NULL; -- ADDRESS 값이 NULL이 아닌 아이를 출력.

-- 55페이지
--QUIZ 1
SELECT * FROM BOOK WHERE PRICE BETWEEN 10000 AND 30000;
--2
SELECT * FROM CONTACT WHERE FIRST_NAME IN ('김','최');
--3
SELECT * FROM GIFT WHERE NAME IN ('노트북','벽걸이 TV','양쪽문냉장고');
--4
SELECT*FROM GIFT WHERE TYPE IN ('생활용품','운동장비');
--5
SELECT*FROM GIFT WHERE PRICE BETWEEN 300000 AND 600000;

--57 페이지
--QUIZ 1
SELECT*FROM CONTACT WHERE PHONE LIKE '%2341';
--2
SELECT*FROM CONTACT WHERE PHONE LIKE '%3171%';
--3
SELECT*FROM CONTACT WHERE EMAIL LIKE '%@naver.com' and PHONE IS NULL;
--4
SELECT*FROM GIFT WHERE TYPE LIKE '%용품'; 
--5
SELECT*FROM GIFT WHERE NAME LIKE '%세트%' AND PRICE<=300000;


--함수 : 기능을 제공해주는 아이들.
-- 문자함수 CHR, LOWER UPPER LTRIM RTRIM TRIM

-- DUAL 뭐임?
SELECT CHR(65) FROM DUAL; -- 대문자 A 출력.
SELECT LOWER ('JENNIE') FROM DUAL; -- 소문자 jennie 출력
SELECT UPPER (EMAIL) FROM CONTACT; -- EMAIL안에 있는 소문자들 대문자로 반환

SELECT LTRIM ('   JENNIE') FROM DUAL; -- 왼쪽에 있는 공백 제거
SELECT LTRIM ('블랙핑크', '블랙') FROM DUAL; -- '핑크' 출력,  (추가 값이 있을경우) 왼쪽부터 일치하는 단어 있을 시 걔를 빼버림
SELECT RTRIM ('JENNIE       ') FROM DUAL; -- 우측에 있는 공백 제거
SELECT RTRIM ('블랙핑크', '핑크') FROM DUAL; -- '블랙' 출력.
SELECT TRIM ('           JEN   NIE              ') FROM DUAL; -- 양쪽에 있는 공백 제거, 문자열 사이에 있는 공백은 제거 못함.
SELECT TRIM (LEADING '블' FROM '블랙핑크') FROM DUAL; -- '랙핑크' 출력, 문자열이 있을 때 앞쪽에서부터 비교를 해서, 맞는 글자를 없애줌. 
-- 뒤에서부터 비교하고 싶을 경우
SELECT TRIM (TRAILING '크' FROM '블랙핑크') FROM DUAL; --'블랙핑' 출력, 뒤에서부터 제거를 함.
SELECT TRIM (BOTH '블' FROM '블랙핑크블') FROM DUAL; -- '랙핑크' 출력, 앞뒤 양쪽에서 확인하고 제거함.

SELECT SUBSTR('블랙핑크제니', 3,2)FROM DUAL ; -- '핑크' 출력, 시작점, 잘라줄 문자. '핑'에서 2개니까 '핑크'를 잘라서 리턴함
SELECT SUBSTR('블랙핑크제니', 3)FROM DUAL ; -- '핑크제니' 출력. 하나만 있을 경우 시작점에서 끝까지를 잘라서 리턴함.

SELECT LENGTH('블랙핑크제니') FROM DUAL; -- 문자열의 길이 4 출력
SELECT REPLACE('블랙핑크제니', '제니','지수') FROM DUAL;  -- '블랙핑크지수' 출력. 주어진 문자열에서, 특정 값을, 다른 값으로 바꿈.
SELECT REPLACE('블랙핑크제니', '제니') FROM DUAL; -- '블랙핑크' 출력, 바꿀 값이 없을 경우 그냥 단순히 빠지기만 함.
-- 적용버전
SELECT REPLACE(LAST_NAME, '시') FROM CONTACT; -- '우' 출력, '시' 가 있는 아이가 빠지게 됨.
SELECT REPLACE(LAST_NAME, '시', '우') FROM CONTACT; -- '우우' 출력, '시' 가 '우'로 대체 됨.


-- ======================================================12/ 8 수업 ==========================================================

-- ABS, SIGN, ROUND, TRUNC, CEIL, FLOOD, MOD
SELECT ABS(-1) FROM DUAL; -- 수의 절대값 반환
SELECT SIGN(-1) FROM DUAL; 

SELECT ROUND (163.37, 1) FROM DUAL; -- 163.37을 소수 첫째자리 까지만 나타내고, 나머지는 반올림하겠다는 의미, 163.4 반환
SELECT ROUND (163.37, -2) FROM DUAL; -- 163.37을 100의 자리만 나타내고 10의 자리에서 반올림하겠다는 의미, 200 반환
SELECT TRUNC(54.29, 1) FROM DUAL; -- 54.2까지만 나타내고 나머지는 버리겠다는 의미. 54.2 반환
SELECT TRUNC(54.29, -2) FROM DUAL; -- 100의 자리서 나타내고 나머지는 버리겠다는 의미. 0 반환.
SELECT CEIL(54.29) FROM DUAL; -- 소수점을 다 버리고 무조건 올림해주겠다는 의미. 55 반환
SELECT FLOOR(54.29) FROM DUAL; -- 소수점을 무조건 버림. 54 반환.
SELECT MOD (15,7) FROM DUAL;  -- 15와 7을 나눈 값의 나머지를 반환함. 1 반환.
-- MOD의 2번째 값이 0일 경우 1번째 값이 그대로 리턴 됨.

-- 날짜 (EXTRACT, ADD_MONTHS)
SELECT EXTRACT(YEAR FROM SYSDATE) AS YEAR FROM DUAL; -- 2022년 출력. (현재 시스템 년도에서 년에 해당되는 데이터 반환)
SELECT EXTRACT(YEAR FROM ORDER_DATE) AS YEAR FROM ORDERS;
SELECT EXTRACT(MONTH FROM ORDER_DATE) AS MON FROM ORDERS;
SELECT EXTRACT(DAY FROM ORDER_DATE) AS DA FROM ORDERS;

SELECT ADD_MONTHS(TO_DATE('2021-12-31', 'YYYY-MM-DD'), -1) FROM DUAL; -- 21/11/30 반환.  ADD_MONTHS(날짜 형태, +-할 기간) 형태로 들어감. 
-- 11월은 31일이 없기 때문에, 11월의 마지막 날인 11월 30일이 반환된다.
SELECT ADD_MONTHS(TO_DATE('2021-12-31', 'YYYY-MM-DD'), +1) FROM DUAL; -- 22/1/31 반환. 


-- 명시적 형변환 함수 (TO_NUMBER, TO_CHAR, TO_DATE)
SELECT TO_NUMBER ('1234') FROM DUAL; -- 1234 반환. 
SELECT TO_NUMBER ('ㄴㅁㅇ') FROM DUAL; -- 에러뜸
SELECT TO_CHAR(1234) FROM DUAL;
SELECT TO_CHAR(SYSDATE) FROM DUAL; -- 날짜형이 아닌, 문자형으로 날짜가 나타남.
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL; -- 포맷한 형태로 날짜가 나타남.
SELECT TO_DATE('2022-12-31', 'YYYY-MM-DD') FROM DUAL;

-- NULL 관련 함수 (NVL, NULLIF, COALESCE)
SELECT NAME, NVL(ADDRESS,  '주소없음') FROM CUSTOMER; -- ADDRESS 값이 NULL 인 경우 '주소없음' 으로 대체되어 반환 됨.
SELECT NAME, NULLIF (ADDRESS, '인천') FROM CUSTOMER; -- ADDRESS값이 '인천' 인 경우 'NULL'로 대체되어 반환 됨.

SELECT NAME, COALESCE(NAME, ADDRESS) FROM CUSTOMER; -- NULL이 아닌 값을 먼저 반환한다. 즉, NAME은 전부 NULL이 아니기 때문에 NAME값을 그대로 리턴함.
SELECT NAME, COALESCE(ADDRESS, NAME) FROM CUSTOMER; -- 생각한 대로임 (조건이 바뀌면 그대로 대응한다)


--DECODE, CASE (IF, ELSE IF에 대응하는!)
SELECT ID, DECODE(ID, 1, 'BLUE', 2, 'RED', 3,'YELLOW',4,'BLACK',5,'WHITE') FROM CUSTOMER; 
    -- ID값이 1이면 블루, 2면은 레드, 3이면 옐로우, 4면 블랙, 5면 화이트 -> 즉 ELSE구문과 비슷하게 먹음
SELECT ID, 
    CASE WHEN ID = 1 THEN 'BLUE'
     WHEN ID = 2 THEN 'RED'
      WHEN ID = 3 THEN 'YELLOW'
       WHEN ID = 4 THEN 'BLACK'
        ELSE 'WHITE'
        END
FROM CUSTOMER;
    
-- 함수 QUIZ
 -- 1 : 3
 SELECT MOD(-15,0) FROM DUAL; 
 -- 2 : 1
 -- 3 : 3
 -- 4 : 2
-- 5 
SELECT NAME, 
 CASE WHEN NAME = '둘리' THEN 'BLUE'
 WHEN NAME = '또치' THEN 'RED'
 ELSE 'WHITE'
 END
 FROM CUSTOMER;
 
 -- 기본키 /  외래키 (PK, FK - 부모자식!)
 
    -- 부서(부모) 테이블 제작
    CREATE TABLE DEPT(
        DEPT_NO NUMBER PRIMARY KEY, -- 부서 번호 (PK)
        DEPT_NAME VARCHAR2(20) NOT NULL, -- 부서명
        DEPT_ADDRESS VARCHAR2(100)   -- 부서주소
    );
 
 INSERT INTO DEPT VALUES (1, '인사부', '');
 INSERT INTO DEPT VALUES (2, '연구부', '');
 INSERT INTO DEPT VALUES (3, '홍보부', '');
 INSERT INTO DEPT VALUES (4, '개발부', '');
 
 SELECT * FROM DEPT;
    
    -- 사원(자식) 테이블 제작
    CREATE TABLE EMP(
        EMP_NO NUMBER PRIMARY KEY, -- 사원번호 (PK)
        EMP_NAME VARCHAR2(20) NOT NULL, -- 사원명
        DEPT_NO NUMBER NOT NULL, -- 부서번호
        CONSTRAINT FK_DEPT_NO FOREIGN KEY(DEPT_NO) REFERENCES DEPT(DEPT_NO)
--  CONSTRAINT FK_지정하려는 컬럼이름 FOREIGN KEY(자식 테이블에 FK 지정하려는 컬럼 이름) REFERENCES 부모테이블 (참조하려는 컬럼 이름)
    );   
    
INSERT INTO EMP VALUES(1001, '정소화', 3); -- DEPT_NO 부서번호 참조하는 아이, 부서테이블의 DEPT_NO안에 있지 않는 데이터는 넣을 수 없다.
INSERT INTO EMP VALUES(1002, '김용욱', 1);
INSERT INTO EMP VALUES(1003, '고명석', 2);
INSERT INTO EMP VALUES(1004, '고명석', 4); -- FK에 대응하는 값이 없을 경우, 에러가 납니다. 무결성 제약조건 위반. 해결하려면 부모 테이블에 대응하는 값을 추가해줘야 함.

UPDATE EMP SET DEPT_NO = 10 WHERE EMP_NAME = '정소화'; -- 무결성 에러난다. UPDATE 할때도 있지 않은 DEPT_NO를 넣으려하면! 
UPDATE EMP SET DEPT_NO = 4 WHERE EMP_NAME = '정소화';
DELETE FROM DEPT WHERE DEPT_NO = 1;  --에러난다. DEPT_NO=1인 아이를 자식 테이블에서 사용하고 있기 떄문에!

DELETE FROM EMP WHERE DEPT_NO = 1;
DELETE FROM DEPT WHERE DEPT_NO = 1; -- 정상적으로 잘 된다. 사용중인 컬럼을 자식테이블에서 먼저 지우고, 부모테이블을 지웠으니까!

DROP TABLE EMP; -- 2. 그래서 참조하고 있는 자식 테이블을 먼저 날려줘야한다.
DROP TABLE DEPT; -- 1. 참조되고 있는 자료가 있기 때문에, 부모 테이블을 먼저 없앨수가 없다.

DROP TABLE DEPT CASCADE CONSTRAINTS; -- 제약조건 다 무시하고 부모테이블을 먼저 날릴 수 있다.

-- QUIZ
CREATE TABLE TEST_CLASS(
CLASS_NO NUMBER PRIMARY KEY,
CLASS_NAME VARCHAR2(20)
);
 
 INSERT INTO TEST_CLASS VALUES(1001, '수학');
 INSERT INTO TEST_CLASS VALUES(1002, '국어');
 
 CREATE TABLE TEST_STUDENT(
STUDENT_NO NUMBER PRIMARY KEY,
STUDENT_NAME VARCHAR2(20)
);

 INSERT INTO TEST_STUDENT VALUES(2001, '정소화');
 INSERT INTO TEST_STUDENT VALUES(2002, '김용욱');
INSERT INTO TEST_STUDENT VALUES(2003, '고명석');

CREATE TABLE TEST_CLASS_STUDENT(
CS_NO NUMBER PRIMARY KEY,
CLASS_NO NUMBER,
STUDENT_NO NUMBER,
CONSTRAINT FK_CLASS_NO FOREIGN KEY(CLASS_NO) REFERENCES TEST_CLASS(CLASS_NO),
CONSTRAINT FK_STUDENT_NO FOREIGN KEY(STUDENT_NO) REFERENCES TEST_STUDENT(STUDENT_NO)
);

INSERT INTO TEST_CLASS_STUDENT VALUES(1, 1001, 2001);
INSERT INTO TEST_CLASS_STUDENT VALUES(2, 1002, 2001);
INSERT INTO TEST_CLASS_STUDENT VALUES(3, 1001, 2002);
INSERT INTO TEST_CLASS_STUDENT VALUES(4, 1002, 2002);
INSERT INTO TEST_CLASS_STUDENT VALUES(5, 1002, 2003);

---------------- 짱 중요한 JOIN ------------------
-- INNER, EQUI, FULL OUTER, LEFT OUTER, RIGHT OUTER JOIN

-- 데이터 넣기
CREATE TABLE ACADEMY_A( -- 학원에 등록한 학생들의 정보
STUDENT_NO NUMBER PRIMARY KEY,
STUDENT_NAME VARCHAR(20) NOT NULL
);

DROP TABLE ACADEMY_A;

CREATE TABLE ACADEMY_B(
STUDENT_NO NUMBER PRIMARY KEY,
STUDENT_NAME VARCHAR(20) NOT NULL
);

INSERT INTO ACADEMY_B VALUES(1005, '김태환');
INSERT INTO ACADEMY_B VALUES(1006, '이윤아');
INSERT INTO ACADEMY_B VALUES(1003, '고명석');
INSERT INTO ACADEMY_B VALUES(1004, '김연아'); 
-- ACADEMY_A, ACADEMY_B에 대해 겹치는 데이터 (고명석, 김연아) 가 있음.
-- 겹치는 데이터들을 이용하여 테이블을 묶을 수 있다. 이것이 바로 JOIN.

--EQUI JOIN
SELECT*
FROM ACADEMY_A T1, ACADEMY_B T2
WHERE T1.STUDENT_NO = T2.STUDENT_NO; -- '=' 형태로 JOIN을 사용할 수 있음 (모아올 값의 조건 기준이 됨!)
-- STUDENY_NO 가 동일한 두 아이를 출력하게 됨.

SELECT T1.STUDENT_NO, T1.STUDENT_NAME --> 질문, 별칭을 붙이기 전에 먼저 SELECT에서 값을 가져오는게 가능한가?
FROM SELECT NAME, NVL(ADDRESS,  '') FROM CUSTOMER;
WHERE T1.STUDENT_NO = T2.STUDENT_NO; 
-- T1.STUDENT_NO, T1.STUDENT_NAME 2개만 띄울 수 있음.

--NON-EQUI JOIN
SELECT * FROM ACADEMY_A T1, ACADEMY_B T2
WHERE T1.STUDENT_NO >= t2.student_no; 
-- 같거나 큰 경우이기 때문에, 1003두개가 같을 경우, T1의 값이 더 클 경우, 1004 두개가 같을경우 3가지 케이스가 나온다.

-- INNER JOIN
SELECT * 
FROM ACADEMY_A T1 
JOIN ACADEMY_B T2
ON(T1.STUDENT_NO = T2.STUDENT_NO); -- EQUI JOIN와 동일한 형태로 모아줌.

-- LEFT JOIN
SELECT *
FROM ACADEMY_A T1
LEFT JOIN ACADEMY_B T2
ON(T1.STUDENT_NO = T2.STUDENT_NO) 
ORDER BY T1.STUDENT_NO; 
-- LEFT, 즉 T1의 값은 모두 나오는데, T2는 안나온다.

--RIGHT JOIN
SELECT *
FROM ACADEMY_A T1
RIGHT JOIN ACADEMY_B T2
ON(T1.STUDENT_NO = T2.STUDENT_NO) 
ORDER BY T1.STUDENT_NO; 

 --OUTER JOIN -> 합집합.
SELECT T1.STUDENT_NO, T1.STUDENT_NAME, T2.STUDENT_NO, T2.STUDENT_NAME 
FROM ACADEMY_A T1
FULL OUTER JOIN ACADEMY_B T2
ON(T1.STUDENT_NO = T2.STUDENT_NO) 
ORDER BY T1.STUDENT_NO; 
 
 -- NATURAL JOIN
 SELECT*
 FROM ACADEMY_A T1
 NATURAL JOIN ACADEMY_B T2; -- 같은 이름의 컬럼들이 모두 동일한 데이터일 때. 출력해준다.
 
 
 
 --- QUIZ
  DROP TABLE EMP;
DROP TABLE DEPT;
CREATE TABLE DEPT (
    DEPT_NO      NUMBER PRIMARY KEY,
    DEPT_NAME    VARCHAR2(20) NOT NULL
);
CREATE TABLE EMP (
    EMP_NO      NUMBER PRIMARY KEY,
    EMP_NAME    VARCHAR2(20) NOT NULL,
    DEPT_NO NUMBER NOT NULL,
    CONSTRAINT FK_DEPT_NO FOREIGN KEY(DEPT_NO) REFERENCES DEPT (DEPT_NO)
);
INSERT INTO DEPT VALUES (1, '인사부');
INSERT INTO DEPT VALUES (2, '연구부');
INSERT INTO DEPT VALUES (3, '홍보부');
INSERT INTO EMP VALUES (1001, '정소화', 3);
INSERT INTO EMP VALUES (1002, '김용욱', 1);
INSERT INTO EMP VALUES (1003, '고명석', 2);

-- QUIZ 1
SELECT P1. DEPT_NAME, P2. EMP_NAME FROM DEPT P1 JOIN EMP P2 ON (P1.DEPT_NO = P2.DEPT_NO);

-- QUIZ 2
SELECT P1.STUDENT_NO, P2.STUDENT_NAME, P3.CLASS_NAME FROM TEST_CLASS_STUDENT P1 
LEFT JOIN TEST_STUDENT P2 ON (P1.STUDENT_NO = P2.STUDENT_NO)
LEFT JOIN TEST_CLASS P3 ON (P1.CLASS_NO = P3.CLASS_NO) ORDER BY STUDENT_NO;


CREATE TABLE ACADEMY_C (
    STUDENT_NO NUMBER PRIMARY KEY,
    STUDENT_NAME VARCHAR2(20) NOT NULL
);
INSERT INTO ACADEMY_C VALUES (1004, '김연아');
INSERT INTO ACADEMY_C VALUES (1006, '이윤아');
INSERT INTO ACADEMY_C VALUES (1001, '정소화');
INSERT INTO ACADEMY_C VALUES (1007, '정소화');
SELECT * FROM ACADEMY_A A LEFT JOIN ACADEMY_B B  ON A.STUDENT_NO = B.STUDENT_NO RIGHT JOIN ACADEMY_C C ON A.STUDENT_NO = C.STUDENT_NO ORDER BY STUDENT_NO;



--집합연산자 UNION ALL, UNION, INTERSECT, MINUS
-- UNION ALL
SELECT*FROM ACADEMY_A
UNION ALL 
SELECT* FROM ACADEMY_B; -- 중복되는 값 1003, 1004가 두번 나온 상태로 리턴

--UNION 
SELECT*FROM ACADEMY_A
UNION
SELECT* FROM ACADEMY_B; -- 중복되는 값 1003, 1004가 제거 된 상태로 리턴

--INTERSECT
SELECT*FROM ACADEMY_A
INTERSECT
SELECT* FROM ACADEMY_B; -- 중복되는 값 1003, 1004 만 리턴

--MINUS
SELECT*FROM ACADEMY_A
MINUS
SELECT* FROM ACADEMY_B; -- A테이블에서 B테이블과 중복되는 값 1003, 1004 빼고 리턴

-- 집합연산자는 테이블 구조가 일치해야한다 (컬럼의 이름, 갯수 등)


-- 서브쿼리
 -- 스칼라 서브쿼리 (SELECT안에 또 SELECT)
SELECT T1.STUDENT_NO,
(SELECT T2.STUDENT_NAME
FROM ACADEMY_B T2
WHERE T2.STUDENT_NO = T1.STUDENT_NO) AS NAME
FROM ACADEMY_A T1;
-- A STUDENT의 STUDENT_NO를 가져온 상태에서 (고명석, 김연아의 이름을(A STUDENT_NO와 B STUDENT_NO가 같은 아이들을) 가져온다)
-- 컬럼대신 사용하기 때문에 반드시 하나의 컬럼만 가져와야 한다 (내부 SELECT 에서 가져올 때)!!!


 --인라인 뷰 (FROM 안에 SELECT)
 SELECT T1.STUDENT_NO, T2.STUDENT_NAME
 FROM ACADEMY_A T1, 
 (SELECT STUDENT_NO, STUDENT_NAME
 FROM ACADEMY_B) T2 -- ACADEMY_B에 있는 STUDENT_NO, STUDENT_NAME을 가져온다.
 -- ACADEMY_B에 있는게 위의 두개 컬럼밖에 없기 때문에, 사실상 ACADEMY_B T2와 동일하다.
 WHERE T1.STUDENT_NO = T2.STUDENT_NO;
 -- 
 
 